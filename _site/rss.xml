<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="https://alexjameson.github.io/">
  <title>Александр Яковлев о технике и документации</title>
  <subtitle></subtitle>
  <link href="rss.xml" rel="self" />
  <link href="https://alexjameson.github.io/" />
  <updated>
    2025-05-14T14:00:43Z
  </updated>
  <id>https://alexjameson.github.io/</id>
  <author>
    <name>Александр Яковлев</name>
  </author>
  <entry>
    <title>GitHub Action для запуска CSpell в CI</title>
    <link href="/cspell-github-action/" />
    <updated>2025-05-14T14:00:43Z</updated>
    <id>/cspell-github-action/</id>
    <content xml:lang="" type="html">
      <p>Некоторое время назад я написал статью о том, как использовать <a href="https://habr.com/ru/articles/902236/">CSpell для проверки орфографии</a>. В ней я упомянул, что можно создать GitHub Action для запуска CSpell в рамках CI-пайплайна. В тот момент у меня было только примерное понимание того, как такой Action должен работать, а в продакшене финальный вариант писали уже наши программисты с нуля.</p>
<p>Я решил доделать Action самостоятельно, чтобы дать любому пользователю возможность запускать <a href="https://cspell.org/">CSpell</a> в том числе в пул-реквестах на GitHub.</p>
<h2>Требования и ограничения</h2>
<ul>
<li>
<p>Основным требованием для этого процесса была возможность запуска CSpell с использованием того же конфигурационного файла и тех же словарей, которые могут использоваться локально.</p>
</li>
<li>
<p>CSpell должен запускаться по команде в комментарии, оставленном в пул-реквесте.</p>
</li>
<li>
<p>Проверяться должны те файлы, которые были изменены в пул-реквесте.</p>
</li>
</ul>
<p>Последний пункт несет в себе ограничение, связанное со спецификой работы CSpell. Этот инструмент умеет проверять только файлы целиком, а не отдельные строки. Таким образом, при конфигурации нужно сделать выбор: либо проверять все файлы, в которых есть измененные строки, либо же собрать все измененные в коммитах строки в один временный файл, и проверить уже его. Я сделал выбор в пользу проверки реально существующих файлов, даже с учетом того, что в результатах проверки могут быть ошибки, которые появились не в рамках текущего пул-реквеста. Также у выбранного мной способа есть дополнительное преимущество — при проверке таких файлов будет указана строка, на которой есть слово, содержащее ошибку.</p>
<h2>Реализация</h2>
<p>Главный вызов в создании Action такого рода заключается в правильном вычислении дельты (diff) между HEAD текущей ветки и HEAD ветки, в которую должен быть вмержен пул-реквест (base branch). На маркетплейсе GitHub есть Actions, которые должны позволять это делать, но ни один из них не сработал в моих условиях, так что я взял за основу код, предложенный Claude Sonnet 3.7, и доработал его под свою задачу.</p>
<p>В моей реализации Action работает следующим образом:</p>
<ol>
<li>
<p>В первых четырех шагах (начиная с <code>Checkout repository</code> до <code>Install Russian dictionary</code>) в коде ниже происходит подготовка репозитория и установка всех необходимых пакетов в раннере.</p>
</li>
<li>
<p>На шаге <code>Fetch PR details</code> вычисляется дельта между HEAD текущей ветки и HEAD ветки, в которую должен быть вмержен пул-реквест.</p>
</li>
<li>
<p>В следующих шагах — <code>Checkout PR</code> и <code>Get changed files</code> — подготавливаются файлы, попадающие в вычисленную дельту.</p>
</li>
<li>
<p>Шаг <code>Run CSpell check</code> отвечает непосредственно за запуск проверки орфографии в этих файлах. Также на этом шаге подготавливается контент комментария, который будет отправлен в пул-реквест по окончанию проверки. В этом комментарии будет один из трех возможных результатов:</p>
<ul>
<li>Обнаружены ошибки. В таком случае в комментарии будут отправлены ошибки, которые были найдены в процессе проверки.</li>
<li>Проверка прошла успешно. В таком случае в комментарии будет отправлен текст <code>✅ Spelling check passed for all changed files</code>.</li>
<li>Не обнаружены файлы, подлежащие проверке. В таком случае в комментарии будет отправлен текст <code>✅ No files changed to check.</code>.</li>
</ul>
<p>В данном случае не предусмотрена обработка ошибок, возникающих в ходе запуска Action. Такие ошибки могут быть связаны с неверной конфигурацией, исчерпанием лимита бесплатного времени работы (2000 минут в месяц) и пр.</p>
</li>
<li>
<p>Последний шаг — <code>Comment PR</code> — отправляет комментарий с результатами в пул-реквест.</p>
</li>
</ol>
<p>Пример проверки:</p>
<p><img src="../assets/cspell-action-result.png" alt="cspell check result"></p>
<p>Получившийся файл расположен по адресу <code>.github/workflows/cspell-check.yml</code> и выглядит следующим образом:</p>
<pre><code class="language-yaml">name: CSpell Check

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  cspell-check:
    if: github.event.issue.pull_request && contains(github.event.comment.body, '/check')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install cspell
        run: npm install -g cspell

      - name: Install Russian dictionary
        run: npm install -g @cspell/dict-ru_ru

      - name: Fetch PR details
        id: pr-details
        run: |
          PR_NUMBER=$
          PR_DATA=$(curl -s -H "Authorization: token $" \
            "https://api.github.com/repos/$/pulls/$PR_NUMBER")
          
          BASE_REF=$(echo "$PR_DATA" | jq -r .base.ref)
          HEAD_REF=$(echo "$PR_DATA" | jq -r .head.ref)
          HEAD_SHA=$(echo "$PR_DATA" | jq -r .head.sha)
          
          echo "base_ref=$BASE_REF" >> $GITHUB_OUTPUT
          echo "head_ref=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT

      - name: Checkout PR
        run: |
          git fetch origin pull/$/head:pr-$
          git checkout pr-$

      - name: Get changed files
        id: changed-files
        run: |
          BASE_REF=$NaN
          git fetch origin $BASE_REF
          
          CHANGED_FILES=$(git diff --name-only origin/$BASE_REF)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          echo "files&lt;&lt;EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run CSpell check
        id: cspell-check
        run: |
          # Get the changed files
          CHANGED_FILES="$NaN"
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "## CSpell Check Result" > comment.md
            echo "" >> comment.md
            echo "✅ No files changed to check." >> comment.md
            exit 0
          fi
          
          # Create a file with the list of files to check
          echo "$CHANGED_FILES" > files_to_check.txt
          
          # Run cspell check
          cspell --no-progress $(cat files_to_check.txt) > cspell_output.txt 2>&1 || {
            # If cspell fails (returns non-zero), it found spelling issues
            echo "## CSpell Check Result" > comment.md
            echo "" >> comment.md
            echo "❌ Spelling issues found:" >> comment.md
            echo "" >> comment.md
            
            # Format the output with newlines after each issue
            grep " - Unknown word" cspell_output.txt > formatted_issues.txt || true
            
            cat formatted_issues.txt >> comment.md
            echo "" >> comment.md # Add an extra newline
            grep "CSpell: Files checked:" cspell_output.txt >> comment.md || true
            exit 0
          }
          
          # If we get here, cspell succeeded (returned zero), no spelling issues
          echo "## CSpell Check Result" > comment.md
          echo "" >> comment.md
          echo "✅ Spelling check passed for all changed files." >> comment.md
          echo "" >> comment.md
          echo "[View Action](https://github.com/$/actions/runs/$)" >> comment.md

      - name: Post comment
        if: always()
        run: |
          PR_NUMBER=$
          COMMENT_BODY=$(cat comment.md)
          COMMENT_JSON=$(jq -n --arg body "$COMMENT_BODY" '{"body": $body}')
          
          curl -s -X POST \
            -H "Authorization: token $" \
            -H "Content-Type: application/json" \
            -d "$COMMENT_JSON" \
            "https://api.github.com/repos/$/issues/$PR_NUMBER/comments"
</code></pre>
<h2>Конфигурация CSpell</h2>
<p>Моя собственная конфигурация CSpell с используемыми словарями подробно описана в <a href="https://habr.com/ru/articles/902236/">статье</a>, на которую я уже ссылался. Здесь я покажу только конфигурационный файл для тестового проекта:</p>
<pre><code class="language-yaml">{
	"version": "0.2",
	"language": "en,ru",
	"import": ["@cspell/dict-ru_ru/cspell-ext.json"],
	"dictionaryDefinitions": [
	  {
			"name": "allowed-en",
			"path": "dicts/allowed-en.txt",
			"addWords": true
	  },	  
	  {
			"name": "allowed-adj",
			"path": "dicts/allowed-adj.txt",
			"addWords": true
	  },
	  {
			"name": "allowed-nouns",
			"path": "dicts/allowed-nouns.txt",
			"addWords": true
	  },
	  {
			"name": "allowed-verbs",
			"path": "dicts/allowed-verbs.txt",
			"addWords": true
	  },
	  {
			"name": "names",
			"path": "dicts/names.txt",
			"addWords": true
	  },
	  {
			"name": "forbidden-ru",
			"path": "dicts/forbidden-ru.txt",
			"addWords": true
	  }
   ],
   "dictionaries": [
	  "allowed-en",
	  "allowed-adj",
	  "allowed-nouns",
	  "allowed-verbs",
	  "names",
	  "forbidden-ru"
   ],
	"ignoreRegExpList": [
		 "```[^]*```",
	],
    "ignorePaths": [
        "node_modules",
        "dicts",
		  ".github"
    ]
}</code></pre>

    </content>
  </entry>
  <entry>
    <title>Сравнение генераторов статических сайтов для создания документации</title>
    <link href="/ssg-comparison/" />
    <updated>2025-05-14T13:59:17Z</updated>
    <id>/ssg-comparison/</id>
    <content xml:lang="" type="html">
      <p>Цель сравнения — помочь людям, которые не слишком хорошо себе знакомы с различными генераторами статических сайтов, составить базовое представление о нескольких распространенных решениях. Обзор не претендует на объективность и показывает в первую очередь мой опыт.</p>
<p>Я сравнил генераторы по нескольким параметрам, которые кажутся мне достаточно важными и при этом доступными для анализа, но получившиеся результаты довольно субъективны. Причина в том, что я сам работаю в Яндексе и последние 4 года я пишу документацию с помощью Diplodoc. Это ведет к тому, что у меня самый актуальный и глубокий опыт именно с этим инструментом, а еще он мне просто нравится.</p>
<p>Результаты могут очень сильно различаться в зависимости от сценариев использования, для простоты я предполагаю, что мы сравниваем генераторы для небольшого документационного проекта объемом в пару десятков уже имеющихся Markdown-файлов. В этом обзоре не затронуты инструменты для AsciiDoc и других языков (за исключением Sphinx) так как у меня нет практического опыта работы с ними. Также я не рассмотрел самый популярный на GitHub генератор статических сайтов на основе Markdown под названием Gatsby, так как он давно стал фактически фреймворком для создания веб-приложений, а также потому, что я не следил за его развитием в последние годы и не ориентируюсь в существующих пяти версиях.</p>
<h2>Базовое сравнение</h2>
<p>Можно выбрать любой из этих генераторов, все они обладают возможностями, которые позволяют делать удобные и кастомизируемые сайты. Везде сейчас есть поддержка диаграмм как кода, переиспользование контента, возможность встраивать генерацию по стандарту OpenAPI и многое другое.</p>
<p>Основные различия заключаются в наличии некоторых дополнительных возможностей, сложности конфигурации и эксплуатации.</p>
<h3>Tl;dr</h3>
<ul>
<li><code>Docusaurus</code> отлично подходит для любых проектов, позволяет добавить интерактивность и кастомизировать что угодно при знании React.</li>
<li><code>MkDocs</code> идеален для быстрого старта и простых проектов, широко распространен в индустрии.</li>
<li><code>Diplodoc</code> подходит для крупных и средних проектов, активно развивается. Единственный генератор в списке с изначально русскоязычным сообществом.</li>
<li><code>Sphinx</code> это сложный инструмент. Нужно быть готовым разбираться во множестве вещей, зато можно сделать практически что угодно.</li>
<li><code>Hugo</code> выделяется скоростью и производительностью, подойдет для самых разных проектов — от блогов до больших порталов.</li>
<li><code>Jekyll</code> остаётся неплохим выбором для практически любых проектов из-за долгой истории, множества плагинов и простоты использования, но постепенно теряет популярность.</li>
</ul>
<h3>Сравнение характеристик</h3>
<table>
<thead>
<tr>
<th>Критерий</th>
<th>Docusaurus</th>
<th>MkDocs</th>
<th>Diplodoc</th>
<th>Sphinx</th>
<th>Hugo</th>
<th>Jekyll</th>
</tr>
</thead>
<tbody>
<tr>
<td>Скорость</td>
<td>Быстро</td>
<td>Очень быстро</td>
<td>Средне</td>
<td>Долго</td>
<td>Средне</td>
<td>Быстро</td>
</tr>
<tr>
<td>Сложность использования</td>
<td>Средняя</td>
<td>Низкая</td>
<td>Средняя</td>
<td>Высокая</td>
<td>Средняя</td>
<td>Низкая</td>
</tr>
<tr>
<td>Документация и сообщество</td>
<td>Отлично</td>
<td>Отлично</td>
<td>Средне</td>
<td>Отлично</td>
<td>Хорошо</td>
<td>Отлично</td>
</tr>
<tr>
<td>Экосистема</td>
<td>Много плагинов, MDX</td>
<td>Material theme, макросы</td>
<td>Плагины, совместимые с <code>markdown-it</code></td>
<td>Есть все</td>
<td>Обширная стандартная библиотека, плагины</td>
<td>Плагины</td>
</tr>
<tr>
<td>Генерация OpenAPI</td>
<td>Встроенная поддержка, плагины</td>
<td>Плагины</td>
<td>Встроенная поддержка, без кастомизации</td>
<td>Больше всего вариантов</td>
<td>Плагины, стандартные средства</td>
<td>Плагины, стандартные средства</td>
</tr>
</tbody>
</table>
<h2>Подробный разбор</h2>
<h3>Docusaurus</h3>
<p>Разработчик и дата выпуска: Meta (Facebook), 2017 год | <a href="https://docusaurus.io/">Сайт</a></p>
<ul>
<li>Язык: JavaScript</li>
<li>Сложность использования: Средняя. Для базового использования достаточно знания Markdown, для кастомизации нужны знания React.</li>
<li>Документация и сообщество: Отличная документация, большое активное сообщество, множество примеров.</li>
<li>Локализация и версионирование: Встроенная поддержка.</li>
<li>Экосистема: Богатая. Поддержка MDX, множество плагинов, темы.</li>
<li>Переиспользование контента: MDX компоненты.</li>
<li>OpenAPI: Интеграция с Redocly, Redoc, поддержка Swagger UI, Docusaurus OpenAPI Plugin.</li>
<li>Поиск: Встроенный локальный поиск + интеграция с Algolia DocSearch.</li>
<li><a href="https://clickhouse.com/docs">Пример сайта: ClickHouse</a>.</li>
</ul>
<p><strong>Мое мнение</strong>:</p>
<p>Прекрасный инструмент, который сочетает в себе простоту и в то же время возможности для создания прекрасных сайтов. Есть возможность быстро начать использовать, добавив все необходимое для комфортного использования документации просто прописав несколько строк в конфигурационном файле — работающий поиск, простая локализация, версионирование, понятные плагины и многое другое.</p>
<p>Важнейшая часть для кастомизации — <a href="https://mdxjs.com/">MDX</a>. Это формат, который позволяет совмещать Markdown и JSX в одном файле и таким образом создавать любые сочетания текста и интерактивных элементов, в том числе используя переменные, условный рендеринг и возможности компонентного подхода.</p>
<p>Этот инструмент также хорошо подходит для создания целых сайтов, в которых документация — только один из разделов, и в таком случае получится сохранить единый стиль для всех частей продукта, причем этот стиль будет проработан фронтендерами с помощью привычных подходов.</p>
<h3>MkDocs</h3>
<p>Разработчик и дата выпуска: Tom Christie, 2014 год | <a href="https://www.mkdocs.org/">Сайт</a></p>
<ul>
<li>Язык: Python</li>
<li>Сложность использования: Низкая. Чистый Markdown с возможностью расширения через плагины, простая конфигурация в YAML.</li>
<li>Документация и сообщество: Хорошая документация, активное сообщество.</li>
<li>Локализация и версионирование: Через плагины.</li>
<li>Экосистема: Material theme значительно расширяет функциональность инструмента, множество плагинов.</li>
<li>Переиспользование контента: Макросы.</li>
<li>OpenAPI: Через плагины (swagger-ui).</li>
<li>Поиск: Встроенный поиск в Material theme.</li>
<li><a href="https://help.camera.rt.ru/">Пример сайта: Видеонаблюдение Ростелеком</a>.</li>
</ul>
<p><strong>Мое мнение</strong>:</p>
<p>Говорим MkDocs — чаще всего подразумеваем тему или фреймворк <a href="https://docs.readthedocs.io/en/stable/intro/mkdocs.html">Material for MkDocs</a>, я уже давно не видел проектов только на MkDocs без Material. В своей основе MkDocs это предельно простой генератор, я бы даже рискнул назвать его примитивным. А Material for MkDocs расширяет его функциональность, добавляя умный поиск, продвинутое форматирование, разные визуальные элементы вроде вкладок и аннотаций, поддержку диаграмм как кода и так далее.</p>
<p>Я использовал его для прототипирования сайта с документацией для одного из проектов по работе, и мне понадобилось меньше получаса чтобы показать уже собранный и готовый к выкладке сайт с несколькими страницами документации. Это быстро, понятно и довольно удобно, но в то же время не все готовы мириться с тем, как выглядит готовый сайт, и что кастомизировать его будет непросто.</p>
<h3>Diplodoc</h3>
<p>Разработчик и дата выпуска: Яндекс, 2022 год | <a href="https://diplodoc.com/ru">Сайт</a></p>
<ul>
<li>Язык: JavaScript</li>
<li>Время развертывания: 30-45 минут.</li>
<li>Сложность использования: Средняя. Своя система шаблонов и форматирования.</li>
<li>Документация и сообщество: Базовая документация, небольшое русскоязычное сообщество.</li>
<li>Поддержка диаграмм: Встроенная поддержка (Mermaid).</li>
<li>Локализация и версионирование: Нужно описывать конфигурацию самостоятельно, но поддержка в планах.</li>
<li>Экосистема: Любые плагины, совместимые с парсером <a href="https://github.com/markdown-it/markdown-it">markdown-it</a>. Самому с этим справиться непросто.</li>
<li>Переиспользование контента: Встроенный механизм на нескольких уровнях, от блоков до целых страниц.</li>
<li>OpenAPI: Встроенная поддержка, включая плейграунд.</li>
<li>Поиск: Интеграция с Lunr.</li>
<li><a href="https://ydb.tech/docs/ru/">Пример сайта: YDB Docs</a>.</li>
</ul>
<p><strong>Мое мнение</strong>:</p>
<p>Это хороший инструмент, который сделан в первую очередь для средних и крупных проектов. В основе работы с Markdown - свой диалект (YFM), который даёт больше возможностей, чем практически у всех остальных инструментов в этом списке.</p>
<p>Помимо обычных статических страниц, можно декларативно описывать кастомные страницы (например разводящие страницы) с помощью <a href="https://diplodoc.com/docs/ru/project/page-constructor">Page Constructor</a>. Технический писатель может делать это самостоятельно, и эти страницы будут выглядеть действительно хорошо, как в <a href="https://diplodoc.com/docs/ru/project/pc-example1">этом примере</a>.</p>
<p>Для крупных проектов у этого инструмента есть некоторые особые возможности, например пресеты переменных, которые позволяют легко генерировать из одной текстовой базы несколько разных версий документации, а также хорошая производительность, которая позволяет собирать сайты из репозиториев объемом даже в пару гигабайт, знаю по своему опыту.</p>
<p>Diplodoc — это определенно не самый просто инструмент для самостоятельной настройки. Я знаю технических писателей, которые успешно с этим справляются и даже создают полноценные пайплайны для CI/CD, но не все могут это сделать.</p>
<h3>Sphinx</h3>
<p>Разработчик и дата выпуска: Georg Brandl для Python Software Foundation, 2008 год | <a href="https://www.sphinx-doc.org/en/master/index.html#">Сайт</a></p>
<ul>
<li>Язык: Python</li>
<li>Сложность использования: Высокая. Использует reStructuredText (хотя поддерживает и Markdown), сложная конфигурация.</li>
<li>Документация и сообщество: Обширная документация, большое устоявшееся сообщество.</li>
<li>Локализация и версионирование: Встроенная поддержка обеих функций, продвинутые инструменты для перевода.</li>
<li>Экосистема: Богатейшая экосистема расширений.</li>
<li>Переиспользование контента: Продвинутая система директив.</li>
<li>OpenAPI: Через расширения, множество способов.</li>
<li>Поиск: Встроенный поиск, возможность интеграции с внешними системами.</li>
<li>Дополнительные преимущества:
<ul>
<li>Превосходная поддержка LaTeX и PDF</li>
<li>Автоматическая генерация документации из кода (Docstrings)</li>
<li>Кросс-референсы между проектами</li>
<li>Семантическая разметка</li>
</ul>
</li>
<li><a href="https://docs.kernel.org/">Пример сайта: Linux Kernel</a>.</li>
</ul>
<p><strong>Мое мнение</strong>:</p>
<p>Sphinx — это самый зрелый и гибкий инструмент в списке, с помощью которого можно решить практически любую задачу. С другой стороны, процесс решения точно не будет простым — у этого инструмента очень крутая кривая обучения. Однако, это окупается впоследствии, если он оказывается в руках человека или команды, обладающих достаточными техническими навыками.</p>
<p>Spinx появился как инструмент для документирования кода на Python, но давно вышел за пределы экосистемы и получил множество новых применений. В отличие от остальных инструментов, он позволяет работать как с Markdown, так и с reStructuredText, для которого был изначально создан. Markdown обрабатывается с помощью MyST-Parser, что позволяет еще и выбрать, какие элементы как нужно обрабатывать.</p>
<p>Также Sphinx из коробки позволяет автоматически генерировать документацию из комментариев в коде, причем с помощью разных стилей таких комментариев. А еще поддерживает LaTeX, экспорт в PDF, множество разных способов отображения справочников, API, возможность включать фрагменты кода из других проектов...</p>
<p>В общем, Sphinx подойдет для любых возможных задач для любых крупных и средних проектов, но для проектов меньших масштабов или при отсутствии людей, которые в состоянии справиться с его сложностью, он может принести немало головной боли.</p>
<h3>Hugo</h3>
<p>Разработчик и дата выпуска: Steve Francia, 2013 год | <a href="https://gohugo.io/">Сайт</a></p>
<ul>
<li>Язык: Go</li>
<li>Сложность использования: Средняя. Требует понимания Go templates для кастомизации.</li>
<li>Документация и сообщество: Подробная документация, активное сообщество.</li>
<li>Локализация и версионирование: Встроенная многоязычность, версионирование через ветки.</li>
<li>Экосистема: Множество тем и shortcodes.</li>
<li>Переиспользование контента: Partial templates, shortcodes.</li>
<li>OpenAPI: Через внешние инструменты и shortcodes.</li>
<li>Поиск: Через интеграции (Algolia, Lunr).</li>
<li>Дополнительные преимущества:
<ul>
<li>Самая быстрая сборка среди SSG</li>
<li>Отличная производительность сайтов</li>
</ul>
</li>
<li><a href="https://docs.ozon.ru/common">Пример сайта: Ozon Docs</a></li>
</ul>
<p><strong>Мое мнение</strong>:</p>
<p>Hugo лично у меня вызвал противоречивые чувства. Для работы он требует установки Go, а потом позволяет собирать сайты с помощью крошечного бинарника без внешних зависимостей — просто и элегантно. Скорость работы потрясающая, а с самого начала получается сделать красивый сайт стандартными средствами, в сам инструмент уже встроено практически все, что нужно для работы. Есть и свой парсер Markdown — Goldenmark, и shortcodes, с помощью которых можно легко переиспользовать контент и прочие атрибуты инструмента, который считается стандартом индустрии.</p>
<p>Но потом начинаются сложности, которые не дали мне как следует поисследовать Hugo в свободное время. После первых шагов хочется изучить возможности для кастомизации. Их у Hugo не просто много, а очень много. Вместо shortcodes можно использовать Partial templates, что требует понимания работы темплейтов в Go. Если темплейты Liquid (Jekyll, у Diplodoc аналогичный синтаксис) или Jinja2 мне оказались вполне понятны, то осмыслить темплейты в Go я так и не смог, хотя несколько раз пытался. Дальше появляются какие-то таксономии, функции, ресурсы страниц, хуки, модули и другие элементы.</p>
<p>Мне приходится поверить на слово, что это отличный инструмент. Мне понравился тестовый проект, но я сомневаюсь, что без разработчиков, владеющих Go, его можно без проблем использовать в продакшене.</p>
<h3>Jekyll</h3>
<p>Разработчик и дата выпуска: Tom Preston-Werner (GitHub), 2008 год | <a href="https://jekyllrb.com/">Сайт</a></p>
<ul>
<li>Язык: Ruby</li>
<li>Сложность использования: Низкая для базового использования, средняя для кастомизации.</li>
<li>Документация и сообщество: Хорошая документация, большое устоявшееся сообщество.</li>
<li>Локализация и версионирование: Базовая поддержка.</li>
<li>Экосистема: Множество плагинов и тем, особенно для блогов.</li>
<li>Переиспользование контента: Includes, layouts.</li>
<li>OpenAPI: Через плагины и интеграции.</li>
<li>Поиск: Через плагины (Lunr, Algolia).</li>
<li>Дополнительные преимущества:
<ul>
<li>Нативная интеграция с GitHub Pages</li>
<li>Простота использования</li>
<li>Большое количество готовых тем</li>
</ul>
</li>
<li><a href="https://deckhouse.ru/products/kubernetes-platform/documentation/v1/">Пример сайта: Deckhouse</a></li>
</ul>
<p><strong>Мое мнение</strong>:</p>
<p>Это был первый генератор статических сайтов, который я попробовал использовать, причем сделал это я еще до того как официально стал техническим писателем. В то время Ruby on Rails еще не вызывал удивления, и я с удовольствием поставил его себе в систему, ознакомился с концепцией Gems и сделал свой первый статический сайт (вроде бы блог). Не то чтобы это было просто, но результат мне вполне понравился.</p>
<p>Jekyll создавался в комьюнити Ruby, практически одновременно с GitHub, и они всегда были тесно связаны. Вы ведь наверняка неоднократно указывали <code>.nojekyll</code> при развертывании на GitHub Pages, правда? В те времена люди умели писать простую и понятную документацию, и руководства по Jekyll до сих пор остаются для меня примером.</p>
<p>За годы присутствия на рынке Jekyll популяризовал то, что потом использовалось в десятках других генераторов — Front Matter, шаблоны Liquid, includes и многое другое. Отличительной чертой Jekyll всегда была простота, которая до сих пор впечатляет, а наработки сообщества предлагают широкий выбор для кастомизации сайта.</p>
<p>Сейчас Jekyll редко является очевидным выбором для новых проектов. Он фактически прекратил развиваться, а сам Ruby из модного языка с крупным сообществом стал скорее экзотикой. Появились новые подходы и новые инструменты, предлагающие другие возможности, но классика всегда останется классикой.</p>

    </content>
  </entry>
</feed>

